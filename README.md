# Unit-4



1)  Почему использование тестовых заглушек может быть полезным при написании модульных тестов?

Использование тестовых заглушек (mock objects) может быть полезным при написании модульных тестов по нескольким причинам:

Изоляция зависимостей: Заглушки позволяют изолировать тестируемый объект от его зависимостей. Это позволяет сосредоточиться на тестировании конкретного модуля, не затрагивая другие компоненты системы. Заглушки могут имитировать поведение зависимостей, чтобы тестировать только то, что является целью текущего модуля.

Контроль поведения: С помощью заглушек можно контролировать поведение зависимостей и задавать ожидаемые результаты и возвращаемые значения. Это позволяет создавать специфические сценарии для тестирования различных ветвей кода или обработки ошибок.

Ускорение тестирования: Заглушки могут быть более легковесными и быстрыми в работе, чем реальные зависимости, такие как базы данных или удаленные сервисы. Использование заглушек позволяет ускорить выполнение тестов и снизить их зависимость от внешних ресурсов.

Воспроизводимость: Заглушки позволяют создавать повторяемые тестовые сценарии, в которых можно задавать определенные условия и проверять, как система реагирует на них. Это помогает обнаруживать и исправлять ошибки в контролируемой среде.

Тестирование граничных случаев: Заглушки могут быть использованы для тестирования граничных случаев, которые может быть сложно воссоздать с реальными зависимостями. Например, заглушка может эмулировать ситуацию, когда база данных недоступна или возвращает некорректные данные.

Общий принцип использования заглушек заключается в том, чтобы создать контролируемую и предсказуемую среду для тестирования, исключив внешние факторы и зависимости. Это помогает разработчикам более точно и эффективно проверять функциональность своего кода и быстрее обнаруживать и исправлять ошибки.




2) Какой тип тестовой заглушки следует использовать, если вам нужно проверить, что метод был вызван с определенными аргументами?

Для проверки того, что метод был вызван с определенными аргументами, следует использовать заглушку  "mock" (мок-объект).

Мок-объект - это объект, которые имитирует поведение реальных объектов, но не содержат реализации всех их методов. Он может быть настроены на возвращение определенных значений или генерацию исключений при вызове определенных методов.

Для проверки того, что метод был вызван с определенными аргументами, можно использовать методы verify() и ArgumentCaptor(). Метод verify() позволяет проверить, был ли вызван определенный метод объекта, а ArgumentCaptor() - получить значения аргументов, переданных в этот метод.

Возьмем как пример, класс BookService, который зависит от репозитория BookRepository, и мы хотим проверить, что метод addBook() вызывается с определенными аргументами, мы можем создать мок-объект BookRepository и настроить его на возврат ожидаемых значений. Затем мы вызываем метод addBook() на объекте BookService и используем методы verify() и ArgumentCaptor() для проверки, что метод был вызван с нужными параметрами:



@Test
public void testAddBook() {
    // Создаем мок-объект BookRepository
    BookRepository bookRepository = Mockito.mock(BookRepository.class);

    // Создаем объект BookService с использованием мок-объекта
    BookService bookService = new BookService(bookRepository);

    // Вызываем метод addBook() на объекте BookService
    bookService.addBook("1234567890", "Java Programming", "John Doe");

    // Проверяем, что метод addBook() был вызван на мок-объекте BookRepository с нужными параметрами
    ArgumentCaptor<Book> argument = ArgumentCaptor.forClass(Book.class);
    Mockito.verify(bookRepository).addBook(argument.capture());
    assertEquals("1234567890", argument.getValue().getISBN());
    assertEquals("Java Programming", argument.getValue().getTitle());
    assertEquals("John Doe", argument.getValue().getAuthor());
}
В этом коде мы создаем мок-объект BookRepository и настраиваем его на возврат ожидаемых значений. Затем мы вызываем метод addBook() на объекте BookService с определенными аргументами. Используя методы verify() и ArgumentCaptor(), мы проверяем, что метод addBook() был вызван на мок-объекте BookRepository с нужными параметрами.



3) Какой тип тестовой заглушки следует использовать, если вам просто нужно вернуть определенное значение или исключение в ответ на вызов метода?

Если нам просто нужно вернуть определенное значение или сгенерировать исключение в ответ на вызов метода в рамках тестирования, то можем использовать моки (mocks) или заглушки (stubs). Оба типа представляют собой объекты, которые могут имитировать поведение других объектов или интерфейсов.

Основное различие между моками и заглушками заключается в том, что моки обычно предоставляют способ проверки, каким образом объект был использован в тесте (например, сколько раз был вызван метод и с какими аргументами), тогда как заглушки просто предоставляют результат или генерируют исключение.

Если нам важно проверить, как вызывается метод и с какими аргументами, вместе с возможностью задать возвращаемое значение или исключение, то использование мока может быть предпочтительным. Если же нам нужно только вернуть определенное значение или исключение, применение заглушки может быть более простым и удобным вариантом.

В различных языках программирования существуют различные фреймворки и библиотеки для создания моков и заглушек. Например, в Python популярные библиотеки для создания моков и заглушек включают unittest.mock, pytest-mock, и MagicMock. В Java вам могут понадобиться фреймворки, такие как Mockito или EasyMock. В каждой конкретной ситуации следует выбирать соответствующий инструментарий в зависимости от языка программирования и фреймворка тестирования, которые вы используете.



4) Какой тип тестовой заглушки вы бы использовали для имитации  взаимодействия с внешним API или базой данных?

Для имитации взаимодействия с внешним API или базой данных, рекомендуется использовать заглушку типа "mock" (мок).

Моки - это объекты, которые имитируют поведение реальных объектов и могут быть настроены на ожидаемые вызовы методов и возвращение заданных значений. Они позволяют тестировать код, который зависит от внешних сервисов или баз данных, без фактического подключения к ним.

Существует несколько библиотек для создания моков, таких как Mockito, EasyMock, PowerMock и другие. Вот пример использования Mockito для создания мока и настройки его на ожидаемый вызов метода и возвращение заданного значения:


@Test
public void testGetDataFromExternalAPI() {
    // Создаем мок для внешнего API
    ExternalAPI externalAPI = Mockito.mock(ExternalAPI.class);

    // Настраиваем мок на ожидаемый вызов метода и возвращение заданного значения
    Mockito.when(externalAPI.getData()).thenReturn("Test data");

    // Создаем объект, который зависит от внешнего API
    DataProcessor dataProcessor = new DataProcessor(externalAPI);

    // Вызываем метод, который использует внешнее API
    String result = dataProcessor.processData();

    // Проверяем, что результат равен ожидаемому значению
    assertEquals("Test data processed", result);
}
В этом примере мы создаем мок для внешнего API с использованием Mockito и настраиваем его на ожидаемый вызов метода getData() и возвращение значения "Test data". Затем мы создаем объект DataProcessor, который зависит от внешнего API, и вызываем метод processData(). Используя метод assertEquals(), мы проверяем, что результат равен ожидаемому значению.
